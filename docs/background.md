# Background Information

The exploring secure boot research project focuses on investigating how secure boot is implemented on various microcontrollers and embedded devices. 

**Secure Boot** is essentially a method of ensuring that only trusted or signed operating system code is executed on a device's bootup, it is primarily intended to prevent the injection or execution of malware in the stages before or between the firmware and the operating system exeuction [1]. This is because malware executed at this stage can circumvent other security systems in place at the operating system level. Secure boot is typically associated with traditional forms of computing on operating systems such as Windows, MacOS, Linux, etc., although the principles can be applied to embedded devices as long as their nature as memory-constrained devices are kept in mind. As such, secure boot on embedded devices has required solutions unique to the methods used in traditional computing. As mentioned in *"A Survey of of secure boot schemes for Embedded Systems"*[2], there are three main implementation methods: hardware-based, software-based, and hybrid methods. Hardware-based methods typically make use of Trusted Platform Computing. Software-based methods differ from hardware-based in that they typically require more overhead but no external hardware systems. Hybrid methods fit into neither category cleanly and typically use a combination of software or hardware-based methods. 

## On Hardware-based Secure Boot

Hardware-based secure boot implementations primarily come in two forms: a hardware block dedicated to crytographic operations or the management of keys, or a secondary general purpose processing unit that executes secure operations [3]. Regardless of which method is used, the main purpose of using a hardware implementation is to establish trust between firmware operations and High-Level Operating system execution. The benefits with hardware-based solutions include: high physical security, ease of implementing anti-tampering mechanisms, ... However, the main drawbacks include the cost of design and integration into new systems (as the hardware must be included in the design of a new product or SoC) and the inflexible nature of hardware components especially for ease of integrating improvements or updates. Two significant issues that arise with using hardware-based secure boot solutions include the fact that the passage of secure information to insecure places in memory can risk the integrity of the secure information if proper precautions are not taken. Another prevalent issue comes from debug interfaces in that hardware solutions may require use of JTAG or UART debugging interfaces, but they also cannot be left enabled on an end-device. The usage of debug interfaces to access the firmware on a device is a common practice and can lead to an end-user accessing information that could risk the integrity of the device. 

### Hardware-block Based Solutions

In the case of the first case with a hardware-block, a **root of trust** is established using a set of encryption keys either generated by and stored on the device, generated by the manufacturer of a device, or a combination of both. These encryption keys are then used to sign files, which means the signed file is verified or trusted by the hardware-block. Different microcontroller platforms make use of different encryption schemes, such as Arduino's MCUBoot secure boot solution using using the Elliptic Curve Integrated Encryption Scheme [4] or Espress-ifs ESP32 series making use of AES based encryption keys in newer implementations of secure boot[5]. A common problem with hardware-block based solutions is the risk of compromised encryption keys. If keys cannot be regenerated or revoked, attacks that target compromising encryption keys could render these defenses useless. 

### Secondary General Purpose Processor Based Solutions

In implementations that make use of a secondary general-purpose processor, all secure operations occur within the secondary processor, then some sort of interface or API must be used to retrieve secure information to an insecure location. This particular design is slightly more difficult to implement as adding a secondary processor takes     

References: 
1. https://uefi.org/sites/default/files/resources/UEFI_Secure_Boot_in_Modern_Computer_Security_Solutions_2013.pdf
2. Wang, R., & Yan, Y. (2022). A Survey of Secure Boot Schemes for Embedded Devices. 2022 24th International Conference on Advanced Communication Technology (ICACT), 224â€“227. 
3. (Arm Trustzone Whitepaper)
4. https://blog.arduino.cc/2022/04/12/introducing-the-arduino-secure-boot/
5. https://blog.espressif.com/esp32-s2-security-improvements-5e5453f98590
