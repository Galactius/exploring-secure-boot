# Notes from resources: 

## "A survey of Secure Boot Schemes for Embedded Devices" 
- Secure boot is "a process of measuring the integrity and authenticity of the operating system kernel and application software running on the device at the booting time" 
- Secure boot guarantees "that the embedded devices boot up with an untampered and authorized software provided by a legitimate vendor"
- Existing models of Secure Boot already exist but may not be appropriate for embedded systems as they are resource-constrained. 
- Three different embedded secure boot schemes: software-based, hardware-based, and hybrid. There are by far many more hardware-based than software or hybrid mentioned in this study.  
- Game me a few other papers to read... 


## UEFI Secure Boot In Modern Computer Security Solutions (UEFI Whitepaper)
- https://uefi.org/sites/default/files/resources/UEFI_Secure_Boot_in_Modern_Computer_Security_Solutions_2013.pdf
- Interesting history about BIOS: The Basic Input/Output system was written by IBM in assembly for computers using 16-bit 8086/8088 Intel processors in the 1970s, that firmware implementation was expanded for future use. In the 1990s, Intel developed the Extensible Firmware Interface (EFI) as an alternative to BIOS for their 64-bit Itanium processors and released the standard specificaiton in 2002, which was then transferred to the United EFI (UEFI) forum. In November 2010, the UEFI forum developed a specificatio that drastically enhanced security for booting OSes. 
- Attacks that target the time between firmware and operating system code has arisen since the 80's. This is because anti-malware and anti-virus software has becoming increasingly effective. Rootkits or Bootkits that target systems before the operating system boots would circumvent all of these countermeasures. In order to protect from these forms of attacks, UEFI and secure boot technologies were developed. 
- Rootkits and Bootkits are particularly difficult to detect and remove, as malware hidden in firmware cannot be easily detected by an OS unless it has tools to scan firmware. Rootkits and bootkits are also dangerous in that firmware provides the malware hardware-level access, which allows it to make use of Virtual Machine technology to mask itself or embed itself into the System ROM, which makes the malware impervious to OS reinstallation and hard-drive replacement. 
- Firmware rootkits work by patching or replacing the default firmware image, while bootkits inject malware at the point between firmware and OS code execution. Various kinds of attacks, such as the evil maid attack (where someone installs a bootkit on a public, unattended PC which can then capture user credentials), or bootloader hijacks exist. 
- Some existing firmware protections include the Trusted Computing Group's Trusted Platform Module (TPM) which takes measurements of all phases of the booting process and allows for an OS to detect modified boot code, although it does not inherently prevent it. 
- The US Govt's NIST guidelines 800-147, 800-147B, and 800-155 provide guidelines for BIOS protections but do not solve bootkit attack issues. 
- Keys and signatures are used to verify code before its executed. The Platform Key is set by a manufacturer in the factory, while it can be replaced its primary use is to protect the Key Exchange Key from uncontrolled modification. THe KEK protects the signature database from unauthorized operations, and operations cannot occur without the private portion of the key. The database contains authorized and forbidden code which can be accessed based on whether the accessor is trusted. As a computer boots, a code section is loaded (but not yet executed), its signature is confirmed using the signature database, that code section executes if and only if that signature matches the same one in the signature database. 
- UEFI secure boot is optional, can be disabled, and can also be reinforced using a TPM module, or other security features. The point of UEFI is that the standards are open, not every part of the standard needs to be active, although it is possible to secure devices more. 

## Cisco: Secure Boot: An Effective, Low-Risk Alternative to Commercial Solutions
- https://www.cisco.com/c/dam/en_us/about/doing_business/trust-center/docs/secure-boot-white-paper-20151009-edcs.pdf
- Secure boot is a technology that prevents start-up code from being modified and protect against malware, logic bombs, and nefarious instructions. It works by "anchoring trust in an element of the system that is rigorously controlled", which is then used to "begin the authentication chain and validate the integrity of the rest of the system". The authentication chain is layered, the previously loaded code must be authenticated before the next layer can be reached. 
- The most important way to mitigate threats of the persistent execution of unauthorized code is to ensure the system boots only authenticated code. This begins with the root of trust. The root helps recover compromised systems and prevent injection scenarios. 
- One major common secure boot technique used in CPUs is to "measure" or hash software as it boots. The measurement itself it taken by a protected environment (likely a trusted platform), where the result is stored in "tamper-resistant" storage. An external system then verifies if the hash is authenticated or not and acts based on the status of the hash. This is called the "measured boot" approach. 
- Another common method is to use an "immutable anchor" (likely a Trusted Platform Module) inside the CPU which validates and sometimes decrypts software that will be executed on the CPU, that way the system can validate code before it is run. 
- A problem with secure boot is that most implementations are CPU-specific. With measured boot, the system that handles failed or unauthorized code has also presented challenges in embedded systems. Also, the key or root of trust used can become a risk if the key is compromised or mishandled, especially in systems that only use one root of trust. At the time of writing, no system handled key revocation. Also, some CPUs had models with and without secure boot, which enabled attackers to swap CPUs in certain systems. 
- An alternative system-level solution (so a solution that requires changes in the design phase, not during or after manufacturing) is to add an FPGA or an ASIC unit that handles the secure boot logic and has control over the CPU's start sequence. This is advantageous in that this means a design could be CPU-agnostic, the logic unit could be an off-the-shelf component, and it could be much more flexible for security improvements as long as an ASIC is not used. 

## Linux-Kernel Trusted Execution Environment Documentation
- https://docs.kernel.org/staging/tee.html
- Github for TEE: https://github.com/OP-TEE/optee_os
- Docs for TEE code: https://optee.readthedocs.io/en/latest/
- A Trusted Execution Environment is a generic term for a secure environment, whether this be done through some sort of special hardware mode (such as the case for ARM TrustZone) or an entirely separate processor. 
- A TEE driver communicates with the TEE, where the driver handles the driver registration, manages shared Linux and TEE memory and provides a generic API. The driver should not really see communications between the client and the TEE, it should simply receive and forward TEE and send back the TEE results of a client's query. 
- The directory: `include/uapi/linux/tee.h` defines a generic interface to a TEE, the client can connect to the driver by opening /dev/tee[0-9]* or /dev/teepriv[0-9]*. A normal client opens the former and a supplicant (a helper process for the TEE to access Linux resources) opens the latter. 
- There are two special implementations of TEE: OP-TEE which seems to be an open source implementation of TEE intended for insecure Linux kernels exclusively for ARM processors and AMD-TEE, which is exclusive to AMD CPUs. 
- More info on OP-TEE: https://wiki.st.com/stm32mpu/wiki/OP-TEE_overview
- In both OP-TEE and AMD-TEE, the user space or client, kernel, and secure world (or AMD Secure Processor for AMD-TEE), are separate but connected using interfaces. The TEE Client API interacts between the client and the kernel, while the a generic TEE API interacts between the Client API and the TEE subsystem within the kernel. There will then be a OP-TEE or AMD-TEE driver that interacts between the TEE subsystem with the kernel and the secure world. The driver then communicates with the OP-TEE or AMD-TEE trusted OS through some sort of messaging protocol. The final layer is some sort of internal secure API which connects the trusted OS to the Trusted Application. 